from tkinter import *
from tkinter import filedialog
import pandas as pd 
import os as os 
from sklearn.feature_extraction.text import CountVectorizer
import seaborn as sn
import matplotlib.pyplot as plt
import numpy as np
from sklearn.model_selection import train_test_split 
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import confusion_matrix

# Function to allow the user to select the folder containing the data.
# Function inputs arg 1: message [string] --> The title for the GUI. 
# Function output 1: directory [string] --> The path of that the folder selected by the user. 
def select_folder(message):
    root = Tk()
    root.title(message)
    root.filename = filedialog.askdirectory(initialdir="/", title=message)
    directory = root.filename
    root.destroy()

    return directory

# Function to load in data from the "sentiment labelled sentences" dataset. 
# Function input arg 1: directory [string] --> The sentiment labelled sentences directory, containing the txt files. 
# Function output 1: df [DataFrame] --> The sentences with corresponding labels and companies.
def load_data(directory):
    
    # Construct a dict to store filepath data for each dataset. 
    filepath_dict = dict.fromkeys(['yelp', 'amazon', 'imdb'])
    filepath_dict['yelp'] = os.path.join(directory, 'yelp_labelled.txt')
    filepath_dict['amazon'] = os.path.join(directory, 'amazon_cells_labelled.txt')
    filepath_dict['imdb'] = os.path.join(directory,  'imdb_labelled.txt')
    
    # Add the .txt data to a pandas DataFrame.
    df_list = [] 
    for company, filepath in filepath_dict.items():
        df = pd.read_csv(filepath, names=['sentence', 'label'], sep='\t') # Where \t is a string literal for the tab character. 
        df['company'] = company
        df_list.append(df)
        
    df = pd.concat(df_list)
    
    return df 

# Function to vectorize the sentences.
# Function input arg 1: df [DataFrame] --> The sentences with corresponding labels and companies.
# Function output 1: sentences_BOW [array] --> The vectorized sentences, as prepared for a bag of words model. 
# Function output 2: labels [array] --> The labels. 
def vectorize_sentences(df): 
    
    # Get the sentences from the DataFrame. 
    sentences = df['sentence'].tolist()
    
    # Vectorize the sentences.
    vectorizer = CountVectorizer(min_df=0, lowercase=False)
    vectorizer.fit(sentences)
    sentences_BOW = vectorizer.transform(sentences).toarray() # BOW: bag of words. 
    
    # Get the array of labels. 
    labels = df['label'].to_numpy()
    
    return sentences_BOW, labels 

# This function creates a confusion matrix to help assess the model. 
# Function inputs arg 1: cm --> The confusion matrix as generated by the function 'confusion_matrix()'
# Function inputs arg 2: classes --> Tuple of strings to label class identities on the plot.  
# Function inputs arg 3: save_plot --> True or Flase. When true, saves plot to data directory.  
# Function inputs arg 4: display_plot --> True or Flase. When true, displays the plot. 
# Function inputs arg 5: cmap --> The chosen colormap. 
# Function output: Figure with the confusion matrix. 
def confusion_matrix_figure(cm,
                            classes,
                            save_plot=True,
                            display_plot=True,
                            normalize=True,
                            cmap=plt.cm.Blues,
                            labels=True):

    # Normalize the data.
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]

    # Create the confusion matrix figure. 
    df_cm = pd.DataFrame(cm, 
                         index = [i for i in classes],
                         columns = [i for i in names])
    plt.rcParams.update({'font.size': 20})
    sn.heatmap(df_cm, 
               annot=True, 
               cmap=cmap, 
               cbar=False, 
               square=True, 
               linecolor='Black', 
               linewidths=1)
    plt.ylabel('True',
                labelpad=20)
    plt.xlabel('Predicted',
               labelpad=20)
    ax = plt.gca()
    ax.set_yticklabels(classes, rotation=90, va="center")

    # Save the plot if the user desires it.
    if save_plot:
        
        if not os.path.exists(os.path.join(directory, 'img')):
            os.makedirs(os.path.join(directory, 'img'))
        
        file_path = os.path.join(directory, 'img', 'confusion_matrix.png')
        plt.savefig(file_path, dpi=200, bbox_inches='tight')
    
    # Display the plot if the user desires it. 
    if (display_plot == False):
        plt.close()
    else:
        plt.show()  
        
# Function to train the model. 
# Function output 1: A confusion matrix, saved to a new directory 'img' within your directory of training data.
def train_model(): 
    
    #### (1) Load the data and vectorize it. 
    
    # Select the directory via a GUI. 
    directory = select_folder('Please select the "sentiment labelled sentences" txt datasets.') 
    
    # Load the data. 
    df = load_data(directory)
    
    # Vectorize the data. 
    sentences_BOW, labels = vectorize_sentences(df)
    
    #### (2) Split the dataset into training and testing subsets.
    
    x_train, x_test, y_train, y_test = train_test_split(sentences_BOW, labels, test_size=0.1)
    
    #### (3) Create and fit data to our model. 
    
    classifier = LogisticRegression()
    classifier.fit(x_train, y_train) 

    #### (4) Create a confusion matrix to evaluate our model. 
    
    y_predictions = classifier.predict(x_test)
    confusion = confusion_matrix(y_test, y_predictions)
    names = ('Negative', 'Positive')
    plt.figure(figsize = (5,5))
    confusion_matrix_figure(confusion,
                            names, 
                            save_plot=True, 
                            display_plot=True)